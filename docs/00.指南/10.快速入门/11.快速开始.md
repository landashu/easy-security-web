---
title: 快速开始
date: 2023-06-25 09:22:36
permalink: /guide/11/
sidebar: true
article: false # 是否未非文章页，非文章不显示 面包屑和作者、时间，不显示最近更新栏，不会参与到最近更新文章的数据计算中
comment: false # 评论区
editLink: false
---
这里我做了一个单项目的基础使用案例，大家可以下载下来运行并自己测试。 项目地址：<a href="https://gitee.com/landashu/east-security-demo.git">https://gitee.com/landashu/east-security-demo.git</a>

## 添加依赖
```
<dependency>
  <groupId>com.aizuda</groupId>
  <artifactId>easy-security-boot-starter</artifactId>
  <version>${latest-version}</version>
</dependency>
```

## 配置
接口权限的统一管理以及配置，我们认为集中化管理和代码无侵入是最好的方式，
当开启认证后，所有的接口都是需要进行认证的，如果你希望某些接口不需要认证，可以通过在 project-url 或 special-url 达到目的。
```
easy:
  security:
    auth-enable: true # 开启认证
    authorize-enable: true # 开启鉴权
    request-data-enable: true # 开启 Req 请求封装
    project-url: # 项目路径，不会被认证，但依然会封装 Req
      - /user/login
    special-url: # 特殊路径，不受认证鉴权影响，不会封装 Req
      - /goods/list
      - /goods/info
```

## 实现EasySecurityServer 
```
@RestController
@RequestMapping("/user")
public class UserController implements EasySecurityServer {
    @Override
    public Object getAuthUser(String token) throws BasicException {
        JWT jwt = JWT.of(token);
        // 验证
        if(!jwt.setKey(key.getBytes()).verify()){
            throw new BasicException(BasicCode.BASIC_CODE_99986);
        }
        // 是否失效
        Long exp = Long.valueOf(jwt.getPayload("exp").toString());
        if(System.currentTimeMillis() > exp){
            throw new BasicException(BasicCode.BASIC_CODE_99985);
        }
        // 返回用户
        UserVO userVO = new UserVO();
        userVO.setId(jwt.getPayload("id").toString());
        userVO.setName(jwt.getPayload("name").toString());
        userVO.setUrl((List<String>) jwt.getPayload("url"));
        return userVO;
    }

    @Override
    public List<String> getAuthorizeUrl(String token) throws BasicException{
        UserVO userVO = (UserVO) getAuthUser(token);
        return userVO.getUrl();
    }
}
```

## 描述你自己的登录逻辑及使用
```
// 模拟登录，登录成功会给前端token，前端需要把token放在Headers中
@PostMapping("/login")
public Rep<UserVO> login(@RequestBody Req<UserDTO,UserVO> req){
    UserDTO userDTO = req.getData();
    if(StrUtil.isEmpty(userDTO.getAccount()) || StrUtil.isEmpty(userDTO.getPassword())){
        return Rep.error(500,"账号或密码错误");
    }
    // 数据库查询
    UserEntity user = db.stream().filter(i -> i.getAccount().equals(userDTO.getAccount())).findAny().get();
    UserVO userVO = new UserVO();
    BeanUtil.copyProperties(user,userVO,"account");
    String token = JWT.create()
            .setPayload("id",user.getId())
            .setPayload("name",user.getName())
            .setPayload("exp", System.currentTimeMillis()+60*60*1000)
            .setPayload("url", userVO.getUrl())
            .setKey(key.getBytes())
            .sign();
    userVO.setToken(token);
    return Rep.ok(userVO);
}

// Req<T,U> 第一个参数为前端所传参数，第二个为后端会获取到的用户数据，
@PostMapping("/selectInfo")
public Rep<UserEntity> selectInfo(@RequestBody Req<String,UserVO> req){
    UserVO userVO = req.getUser();
    UserEntity user = db.stream().filter(i -> i.getId().equals(userVO.getId())).findAny().get();
    return Rep.ok(user);
}
```


## Yapi规则描述
YAPI是一个优秀的代码无侵入的接口文档，只需要按照我们正常的注解去描述我们方法的作用，使用Idea插件，就会自动帮我们生成接口文档。

本框架对YAPI做了一些小功能，隐藏 Req 类中多余的字段，只放出data属性显示到文档中，您需要在项目中的 application.yml 文件里面添加如下：
```
field:
  required: "@com.aizuda.easy.security.annotation.yapi.YApiRule#required"
  default:
    value: "#default"
json:
  rule:
    field:
      ignore: "@com.aizuda.easy.security.annotation.yapi.YApiRule#hide"

method:
  additional:
    header[!@com.aizuda.easy.security.annotation.yapi.YApiRule]: '{name: "token",value: "ddb9ba4f842529e539560b0a6df23408de27dbed00860a1c3c5af04d44fa3c39",required: true}'
```
如果不使用配置则会在这个文档中显示多余的 user 和 token 字段。